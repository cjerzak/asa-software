% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helpers.R
\name{.with_webpage_reader_config}
\alias{.with_webpage_reader_config}
\title{Apply Webpage Reader Configuration for a Single Operation}
\usage{
.with_webpage_reader_config(
  allow_read_webpages,
  relevance_mode = NULL,
  heuristic_profile = NULL,
  embedding_provider = NULL,
  embedding_model = NULL,
  timeout = NULL,
  max_bytes = NULL,
  max_chars = NULL,
  max_chunks = NULL,
  chunk_chars = NULL,
  embedding_api_base = NULL,
  prefilter_k = NULL,
  use_mmr = NULL,
  mmr_lambda = NULL,
  cache_enabled = NULL,
  cache_max_entries = NULL,
  cache_max_text_chars = NULL,
  blocked_cache_ttl_sec = NULL,
  blocked_cache_max_entries = NULL,
  blocked_probe_bytes = NULL,
  blocked_detect_on_200 = NULL,
  blocked_body_scan_bytes = NULL,
  pdf_enabled = NULL,
  pdf_timeout = NULL,
  pdf_max_bytes = NULL,
  pdf_max_pages = NULL,
  pdf_max_text_chars = NULL,
  user_agent = NULL,
  conda_env = NULL,
  fn
)
}
\arguments{
\item{allow_read_webpages}{TRUE/FALSE to enable/disable webpage reading}

\item{relevance_mode}{Relevance selection for opened webpages:
"auto", "lexical", or "embeddings". "auto" uses embeddings when available,
otherwise falls back to lexical overlap.}

\item{heuristic_profile}{Heuristic profile for hyperlink annotation:
"generic" (task-agnostic default) or "legacy".}

\item{embedding_provider}{Embedding provider for relevance ("auto",
"openai", or "sentence_transformers").}

\item{embedding_model}{Embedding model identifier for relevance.}

\item{timeout}{Timeout (seconds) for webpage fetches/embeddings.}

\item{max_bytes}{Download cap in bytes.}

\item{max_chars}{Output cap in characters.}

\item{max_chunks}{Max relevant excerpts to return.}

\item{chunk_chars}{Approximate chunk size (characters).}

\item{embedding_api_base}{OpenAI-compatible base URL for embeddings.}

\item{prefilter_k}{Optional lexical prefilter size before embedding.}

\item{use_mmr}{Whether to apply maximal marginal relevance for diverse excerpts.}

\item{mmr_lambda}{MMR tradeoff between relevance (1.0) and diversity (0.0).}

\item{cache_enabled}{Enable per-run caching.}

\item{cache_max_entries}{Max cached entries per run.}

\item{cache_max_text_chars}{Max extracted text chars to cache per page.}

\item{blocked_cache_ttl_sec}{TTL in seconds for blocked URL cache entries.}

\item{blocked_cache_max_entries}{Max blocked URL cache entries.}

\item{blocked_probe_bytes}{Max bytes read for blocked detection on HTTP errors.}

\item{blocked_detect_on_200}{Detect anti-bot interstitials served with HTTP 200.}

\item{blocked_body_scan_bytes}{Max bytes scanned for blocked markers on HTTP 200 pages.}

\item{pdf_enabled}{Enable PDF extraction via pdftotext.}

\item{pdf_timeout}{Timeout in seconds for pdftotext.}

\item{pdf_max_bytes}{Max PDF bytes downloaded before extraction.}

\item{pdf_max_pages}{Max pages extracted per PDF.}

\item{pdf_max_text_chars}{Max text chars retained from extracted PDF content.}

\item{user_agent}{User-Agent string for webpage fetches.}

\item{conda_env}{Conda env used by Python tools}

\item{fn}{Function to run with webpage reader config applied}
}
\value{
Result of fn()
}
\description{
Internal helper that enables/disables the Python webpage reader tool
for the duration of a single operation, then restores the previous setting.
}
\keyword{internal}
